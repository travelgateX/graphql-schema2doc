

            # The admin query root of TravelgateX's for implementing GraphQL mutations.
type AdminMutation{
  a:Boolean
 
            
  # Create organization. Require an user to be specified as the owner of the group.
  createOrganization(organization: CreateOrganizationInput!): Organization!
  # Create member; requires specific group and role
  createMember(member: CreateMemberInput!) : Member!
  # Create group; group "owner" is optional
  createGroup(group: CreateGroupInput!): Group!
  # Update member additions or remove roles
  updateMember(member: UpdateMemberInput!): Member!
  # Update group additions or remove APIs
  updateGroup(group: UpdateGroupInput!,method: Method!): Group!
  # Delete a member from specific group
  deleteMember(member: [DeleteMemberInput!]!): Member!
  # Delete group and members from this group
  deleteGroup(group: DeleteGroupInput!): Group!
 
            }

            # The admin query root of TravelgateX's GraphQL interface.
type AdminQuery{
  a:Boolean
 
            
  # Organizations list; specify organization codes to filter organizations
  organizations(codes:[ID!],first: Int, last: Int, before: String, after:String): OrganizationConnection!
  # Members list; specify member codes to filter members
  products(codes:[ID!],first: Int, last: Int, before: String, after:String): ProductConnection!
  # Members list; specify member codes to filter members.
  members(codes:[ID!],type: MemberType,first: Int, last: Int, before: String, after:String) : MemberConnection!
  # Groups list; specify group codes to filter groups.
  groups(codes:[ID!],type: GroupType,first: Int, last: Int, before: String, after:String) : GroupConnection!
  # Apis list; specify api codes to filter apis.
  apis(codes:[ID!],first: Int, last: Int, before: String, after:String) : APIConnection!
  # Resources list; specify resource codes to filter resources.
  resources(codes:[ID!],first: Int, last: Int, before: String, after:String) : ResourceConnection!
  # Roles list; specify role codes to filter roles.
  roles(codes:[ID!], type:RoleType, first: Int, last: Int, before: String, after:String) : RoleConnection!
  # Operations list; specify operations codes to filter operations.
  operations(codes: [ID!],type: OperationType, first: Int, last: Int, before: String, after:String): OperationConnection!
 
            }

            type HotelXMutation{
  a:Boolean
 
            
  # Creates a new hotel booking consisting of an option of 1 or more rooms.
  book(input: HotelBookInput!, settings: HotelSettingsInput): HotelBookPayload
  
  # Cancels an existing hotel booking consisting of an option of 1 or more rooms.
  cancel(input: HotelCancelInput!, settings: HotelSettingsInput): HotelCancelPayload
  
  loadFile(input: String!): String! @deprecated(reason: "deprecated from 2018-06-06")
 
            }

            type HotelXQuery{
  a:Boolean
 
            
  # Available options of an hotel for a given date and itinerary. It does not filter different classes, times or
  # fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
  # forward. It only requires the criteria of search (destination, travel dates and the number of pax in each room).
  # But you must preload the other fields in our system by complete the fields absents.
  search(token: String, criteria: HotelCriteriaSearchInput, settings: HotelSettingsInput, filter: FilterInput): HotelSearch
  
  # Returns the total price and cancellation policies of the Option selected in the previous step (Search).
  quote(criteria: HotelCriteriaQuoteInput!, settings: HotelSettingsInput): HotelQuote
  
  # Returns detailed information about books, you can indicated a list of locators or a range date.
  booking(criteria: HotelCriteriaBookingInput!, settings: HotelSettingsInput): HotelBooking
  
  # Returns status of the search service.
  searchStatusService: ServiceStatus!
  
  # Returns status of the quote service.
  quoteStatusService: ServiceStatus!
  
  # Returns status of the new booking service.
  bookStatusService: ServiceStatus!
  
  # Returns status of the cancellation service.
  cancelStatusService: ServiceStatus!
  
  # Returns status of the booking service.
  bookingStatusService: ServiceStatus!
  
  # Returns map codes of a group. You can get hotel map, room map, and board map.
  mapping(groupCode: String!): Mapping!
 
            }

            type MappeaMutation{
  a:Boolean
 
            
  confirmUpload(input: MappeaConfirmUploadInput!): OnlyStatusResponse!
  uploadFile(input: MappeaUploadFileInput!): UploadFileResponse!
  mapSupplier(input: MappeaMapSupplierInput!): OnlyStatusResponse!
 
            }

            type MappeaQuery{
  a:Boolean
 
            
  getUploadedFiles: GetUploadedFilesResponse!
  getMappeaStats(input: MappeaGetMappeaStatsInput!): GetMappeaStatsResponse!
 
            }

            # The root query for implementing GraphQL mutations. Mutations are operations that change or update data on the server
type Mutation {
  admin: AdminMutation
  hotelX: HotelXMutation
  mappea: MappeaMutation
  paymentX: PaymentXMutation
 
            
  # Creates a new hotel booking consisting of an option of 1 or more rooms.
  hotelBook(input: HotelBookInput!, settings: HotelSettingsInput): HotelBookPayload @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
  # Cancels an existing hotel booking consisting of an option of 1 or more rooms.
  hotelCancel(input: HotelCancelInput!, settings: HotelSettingsInput): HotelCancelPayload @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
  
  # Load mapping files for a group.
  loadFile(input: String!): String! @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at Admin")
  
  # Creates a defaultSettings for a given group
  createDefaultSettings(input: DefaultSettingsInput!): DefaultSettings @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at Admin")
  # Updates a defaultSettings for a given group
  updateDefaultSettings(input: DefaultSettingsInput!): DefaultSettings @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at Admin")
  # Deletes a defaultSettings for a given group
  deleteDefaultSettings(input: String!): Boolean! @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at Admin")
 
            }

            type PaymentXMutation{
  a:Boolean
 
            
  # Store Card
  storeCard(input: PaymentXStoreCardInput!): StoredCard!
  # Delete Card
  deleteCard(input: PaymentXBookingInfoDeleteInput!): StoredCard!
 
            }

            type PaymentXQuery{
  a:Boolean
 
            
  # Returns status of the search service.
  vaultStatusService: ServiceStatus!
  
  cards(bookingInfo: PaymentXBookingInfoFilterInput!): StoredCardConnection!
 
            }

            # The query root of TravelgateX's GraphQL interface.
type Query{
  # The admin query root of TravelgateX's for implementing GraphQL query.
  admin: AdminQuery
  # The hotelX product query root for implementing GraphQL query.
  hotelX: HotelXQuery
  # The Mappea product query root for implementing GraphQL query.
  mappea: MappeaQuery
  # The PaymentX product query root for implementing GraphQL query.
  paymentX: PaymentXQuery
  # The Stats product query root for implementing GraphQL query.
  stats: StatsQuery
 
            
  # Available options for a given date and itinerary.
  search: Search! @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
  # Returns the total price and cancellation policies of the Option selected in the previous step (Search).
  quote: Quote! @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
  # Returns detailed information about books.
  booking: Booking @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")

  # Reads defaultSettings of the given group
  defaultSettings(groupCode: String!): DefaultSettings @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")

  # Returns the mapping for a group, is necessary specify the group.
  mapping(groupCode: String!): Mapping! @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
 
            }

            type StatsQuery{
  a:Boolean
 
            
  # The report query, represents all of the entry points into our object graph
  report( filter: StatsFilterInput!, first: Int, last: Int, before: String, after: String): StatsConnection!
 
            }
enum AdviseMessageLevel {
  # Waringn message.
  WARN
  # Error message.
  ERROR
  # Info message.
  INFO
}

# Indicates the type of dates
enum DateType {
  # Arrival Date
  ARRIVAL
  
  # Booking Creation
  BOOKING
}

# Options payment type
enum PaymentType {
  # The payment is managed by the supplier.
  MERCHANT
  
  # The payment is made straight to the actual payee, without sending it through an intermediary or a third party.
  DIRECT
  
  # The payment is managed by the supplier. The payment is effectuated at the time of booking.
  CARD_BOOKING
  
  # The payment is managed by the supplier. The payment is effectuated at check in in the hotel.
  CARD_CHECK_IN
}

# Rate Rules
enum RateRulesType {
  # The product can't be sold separately from another product attached to it, such as a flight.
  PACKAGE
  
  # Options that can only be sold to people who are 55 and older.
  OLDER55
  
  # Options that can only be sold to people who are 60 and older.
  OLDER60
  
  # Options that can only be sold to people who are 65 and older.
  OLDER65
  
  # The rate CanaryResident is applicable to Canary Islands residents only.
  CANARY_RESIDENT
  
  # The rate BalearicResident is applicable to Balearic Islands residents only.
  BALEARIC_RESIDENT
  
  # The rate largeFamily is applied to large families and is determined by each supplier
  LARGE_FAMILY
  
  # The rate honeymoon is applied to those who just got married and is determined by each supplier.
  HONEYMOON
  
  # The rate publicServant is applicable to public servants only.
  PUBLIC_SERVANT
  
  # The rate unemployed is applied to those without work.
  UNEMPLOYED

  #The rate normal refers to options without RateRule
  NORMAL

  #The rate non refundable is applied to non refundable options
  NON_REFUNDABLE
}

# Parameters Input.
input ParameterInput {  
  # Contains the keyword/Id to identify a parameter.
  # This information is mandatory.
  key: String!
  # Contains the parameter values.
  # This information is mandatory.
  value: String!
}

input RelayInput {
  first: Int
  last: Int
  before: String
  after:String
}

# URLs Input
input UrlsInput {
  # Specific URL for Availability method.
  search:         URI
  # Specific URL for Reservation method.
  quote:          URI
  # Specific URL for Valuation method.
  book:           URI
  # Supplier URL used for multiple methods.
  generic:        URI
}

interface AdviseMessage {
  # AM code: The following codes can be returned:
  code: ID!
  # Error type: The following types are valid:
  type: String! @deprecated(reason: "deprecated from 2018-06-01.")
  # Error description
  description: String!
  # Indicates the level of importance of the message: Posible values ERROR WARN INFO
  level: AdviseMessageLevel!
  # Specify the external message.
  external: ExternalMessage
  # Identifier to be able to investigate the cause of the error
  correlationID: ID!
}

interface Node {
  # ID code
  code: ID!
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

interface Text {
  text: String!
  language: Language!
}
# Application errors
type Error {
  # Error code
  code: String!

  # Error type
  type: String!

  # Error description
  description : String!
}

type ExternalMessage	{
  # External Code
  code: String
  # External Message
  message: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

# Url's
type Urls {
  # Specific URL for Availability method.
  search:         URI
  # Specific URL for Reservation method.
  quote:          URI
  # Specific URL for Valuation method.
  book:           URI
  # Supplier URL used for multiple methods.
  generic:        URI
}

# Application warnings
type Warning {
  # Warning code
  code: String!

  # Warning type
  type: String!

  # Warning description
  description : String!
}

# The Country type represents Country values. A good example might be a Passenger Nationality.
# In queries or mutations, Country fields have to be specified in ISO 3166-1 alpha-2 format with enclosing double quotes "ES".
scalar Country

# The Currenty type represents Currency values. A good example might be a Rate Price Currency.
# In queries or mutations, Currency fields have to be specified in ISO 4217 format with enclosing double quotes "EUR".
scalar Currency

# The Date type represents Date values. A good example might be a Hotel CheckIn Date.
# In queries or mutations, DateTime fields have to be specified in ISO 8601 format with enclosing double quotes: "2017-10-22".
scalar Date

# The DateTime type represents DateTime values. A good example might be a transaction TimeSpan.
# In queries or mutations, DateTime fields have to be specified in ISO 8601 format with enclosing double quotes: "2017-10-22T13:57:31.123Z".
scalar DateTime

# The JSON type makes sure that it is actually valid JSON and returns the value as a parsed JSON object/array instead of a string.
# In queries or mutations, JSON fields have to be specified with enclosing double quotes. Special characters have to be escaped: "{\"int\": 1, \"string\": \"value\"}".
scalar JSON

# The Language type represents Language values. A good example might be a Hotel Description Language.
# In queries or mutations, Language fields have to be specified in ISO 3166-1 alpha-2 format with enclosing double quotes "es".
scalar Language

# The URI type represents a URI values. A good example mith be an Hotel Image URL.
# In queries or mutations, URI fields have to be specified in RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string format with enclosing double quotes: "http:\\www.travelgatex.com".
scalar URI

input AccessFilter {
  accessID: [ID]
  group: [ID]
}

# Access input
input AccessInput {
  # Access descriptive unique name
  name: String!
  # Indicates if Access is active
  isActive: Boolean
  # Access code.
  code: ID
  # Supplier for this Access
  supplier: String
  # Indicates if Access can be used for testing or not
  isTest: Boolean
  # User code to connect to supplier
  user: String
  # Password for the connection
  password: String
  # Specific URLs
  urls: UrlsInput
  # List of parameters for additional information
  parameters: [ParameterInput]
  # Markets allowed for the Access
  markets: [String!]
  # Business rule types for the Access
  rateRules: [RateRulesType!]
  # Parent Access if Shared Access.
  shared: String
  # Default group where the access will be visible.
  group: ID
}

input ClientFilter {
  clientID: [ID]
  name: [String!]
  groupID: [ID]
  isActive: Boolean
}

input CreateClientInput {
  # Client complete name
  name: String!
  # Indicates whether a Client is active or inactive
  isActive: Boolean!
  # Group where the client will be assigned at first
	group: String!
}
input GroupInput {
  # Id of the resource permissions to be granted.
  id: ID!
  # Groups that will see this resoruce.
  groups: [ID]
}

input PointOfSaleFilter {
  code: [ID]
  groupID: [ID]
}


input ServiceApiFilter {
 ApiName: String
 OperationName: String
 OperationType: String
}

input SupplierFilter {
  supplierID: [ID]
  accessID: [ID]
  groupID: [ID]
  isActive: Boolean
  serviceAPI: [Int]
 }

input UpdateClientInput {
  # ID identifier of a Client
  code: ID!
  # Client complete name
  name: String
  # Indicates whether a Client is active or inactive
  isActive: Boolean
}
# An Access is a set of credentials and configuration in order to access the system of a Supplier.
type Access implements Node{
  code: ID!
  accessData: AccessData
  # Errors that abort services
  error: [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type AccessConnection{
  edges: [AccessEdge]
  pageInfo: PageInfo!
}

type AccessData {
  # Access descriptive name
  name: String!
  # Indicates if Access is active
  isActive: Boolean!
  # Unique AccessConfiguration identifier
  code: ID!
  # Supplier for this Access
  supplier: Supplier!
  # Indicates if Access can be used for testing or not
  isTest: Boolean!
  # User code to connect to supplier
  user: String
  # Password for the connection
  password: String
  # Specific URLs
  urls: Urls
  # List of parameters for additional information
  parameters: [Parameter]
  # Markets allowed for the Access
  markets: [String!]
  # Business rule types for the Access
  rateRules: [RateRulesType!]
  # Parent Access if Shared Access
  shared: Access
  
}

type AccessEdge {
  cursor: String!
  node: Access
} 

# Client identifies who is making the request and holds the configuration assigned to it.
type Client implements Node{
  code: ID!
  clientData: ClientData
  # Errors that abort services
  error: [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type ClientConnection {
  edges: [ClientEdge]
  pageInfo: PageInfo!
}

type ClientData {
  # ID identifier of a Client
  code: ID!
  # Client complete name
  name: String!
  # Indicates whether a Client is active or inactive
  isActive: Boolean!
}

type ClientEdge {
  cursor: String!
  node: Client
}

# Context type. Currently, only Code is necessary.
type Context implements Node {
  code: ID!
  
  # Errors that abort services
  error: [Error!]
  
  # Date created
  createdAt: DateTime!
  
  # Date updated
  updatedAt: DateTime!
}

# Parameters for additional information for the supplier's configuration.
type Parameter {  
  # Contains the keyword/Id to identify a parameter.
  # This information is mandatory.
  key: ID!
  # Contains the parameter values.
  # This information is mandatory.
  value: String!
}

type PointOfSale implements Node{
  code: ID!
  pointOfSaleData: PointOfSaleData

  # Create date
  createdAt: DateTime!

  # Update date
  updatedAt: DateTime!

  # List of messages
  adviseMessage(level: [AdviseMessageLevel]): [AdviseMessage!]
}

type PointOfSaleConnection {
  edges: [PointOfSaleEdge]
  pageInfo: PageInfo!
}

type PointOfSaleData {
  # POS Identifier
  code: ID!
  # POS Name
  name: String
  # POS Group
  group: Group
}

type PointOfSaleEdge {
  cursor: String!
  node: PointOfSale
}

# Temporary type to use only during SQL server's lifetime
type Provider {
  code: ID!
  name: String!
  isActive: Boolean
  isPublic: Boolean
}

# Information related to a Service API
type ServiceApi {
 # Service API ID
 code: ID!
 # Service API Name
 name: String!
 # Operations that a Service Api has
 operations: [ServiceOperation]
 # Errors
 error: [Error!]
}

# Information related to an API operation
type ServiceOperation {
  # Service Operation ID
  code: ID!
  # Service Operation name
  name: String!
  # Service Operation type
  type: String!
  # Service Operation Travel Operation ID (1: avail) (2: reservation) (3: batch) (4: batchLongRun)
  travelOperation: Int!
}
# A Supplier is a Partner who is connected to TravelgateX on the supply side in order to sell their product to connected Buyers
type Supplier implements Node{
  code: ID!
  supplierData: SupplierData
  # Errors that abort services
  error: [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type SupplierConnection{
  edges: [SupplierEdge]
  pageInfo: PageInfo!
}

type SupplierData{
  # unique identifier of a supplier
  code: ID!
  # Supplier complete name
  name: String!
  # indicates whether a supplier is active
  isActive: Boolean!
  # instance to which this supllier is connected
  provider: Provider!
  # Context where the Supplier belongs to
  context: String!
  # Service API
  serviceApi: Int!
  # SupplierGroup Internal Supplier grouping
  supplierGroup: ID
  # Accesses where the supplier is referenced
  accesses: AccessConnection
}

type SupplierEdge {
  cursor: String!
  node: Supplier
}

# group related to a supplier
type SupplierGroup {
  # group code of the group related to this supplier
  groupCode: String!
  # Indicates if the supplier is active for its supplier
  isActive: Boolean!
}

enum GroupType{
  ORG
  GROUP
  PROFILE
  TEAM
  FOLDER
  PRODUCT
  RESOURCE
  SPECIFIC_RESOURCE
}

enum GroupTypeInput{
  GROUP
  PROFILE
  TEAM
  FOLDER
  PRODUCT
  RESOURCE
  SPECIFIC_RESOURCE
}

enum MemberType {
  USER
  SERVICE_ACCOUNT
}

enum Method {
  ADD
  DEL
}

enum OperationType{
  SEARCH
  QUOTE
  BOOKING
  CANCEL
  SCHEDULER
  CREATE
  READ
  UPDATE
  DELETE
  EXECUTE
  OTHER
}

enum OrganizationTemplate {
  ORGANIZATION_DEFAULT
}

enum RoleType {
  # Allows a User to make Queries of resources, but not change any resource data
  VIEWER
  # Allows a User to make Mutations (changes) to the resource data
  EDITOR
  # Allows a User to make All (changes) to the resource
  ADMIN
  # Allows a User to make use of reources only for extecutations queries.
  EXECUTOR
  # Allows a User to make othen kind of operation with the resource. Defined by API.
  SPECIFIC
}

enum Template {
  FOLDER_DEFAULT
}

input CreateGroupInput{
  group: ID!
  type: GroupTypeInput!
  info: String
  parent: ID!
  template: Template
}

input CreateMemberInput{
  member: ID
  info: String
  type: MemberType!
  group: ID!
  role:  ID!
  resources:  [ID!]!
}

input CreateOrganizationInput {
  user: ID!
  info: String
  organization: ID!
  template: OrganizationTemplate!
}

input DeleteGroupInput {
  code: ID!
}

input DeleteMemberInput {
  member: ID!
  group: ID!
}

input UpdateGroupInput{
  api: ID!
  group: ID!
  info: String
}

input UpdateMemberInput{
  member: ID!
  info: String
  group: ID!
  role:  ID!
  resources:  [ID!]!
  method: Method!
}

interface GroupCommonData{
  id: ID!
  code: ID!
  label: String
  type: GroupType!
  info: String
  children(codes: [ID!], first: Int, last: Int, before: String, after:String): GroupConnection
  owner: Member
  isEditable: Boolean!
  members(codes:[ID!],type: MemberType,first: Int, last: Int, before: String, after:String) : MemberConnection
  apis(codes: [ID!], first: Int, last: Int, before: String, after:String): APIConnection
  allMembers(codes:[ID!],type: MemberType,first: Int, last: Int, before: String, after:String) : MemberConnection
  accesses(codes:[ID!], first: Int, last: Int, before: String, after:String): AccessConnection
  suppliers(codes:[ID!], accessID:[ID!], first: Int, last: Int, before: String, after:String): SupplierConnection
  clients(codes:[ID!],name:[ID!],isActive:Boolean, first: Int, last: Int, before: String, after:String): ClientConnection
}

type API implements Node{
  code: ID!
  apiData: APIData
  # Errors that abort services
  error: [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type APIConnection{
  edges: [APIEdge]
  pageInfo: PageInfo!
}

#
type APIData{
  # API Code
  code: ID!
  # API ID
  id: ID!
  # Is API Editable or not.
  isEditable: Boolean!
  # API label
  label: String
  # which groups are asigned this API?
  groups(codes:[ID!],type: GroupType,first: Int, last: Int, before: String, after:String) : GroupConnection
  # which resources are asigned this API?
  resources(codes: [ID!], first: Int, last: Int, before: String, after:String): ResourceConnection
  # which operations are asigned this API?
  operations(codes: [ID!],type: OperationType, first: Int, last: Int, before: String, after:String): OperationConnection
}

type APIEdge {
  cursor: String!
  node: API
}

# Groups are organized hierarchically.
type Group implements Node{
  code: ID!
  groupData: GroupData
  # Errors that abort services
  error: [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type GroupConnection{
  edges: [GroupEdge]
  pageInfo: PageInfo!
}

type GroupData implements GroupCommonData{
  id: ID!
  code: ID!
  label: String
  type: GroupType!
  info: String
  parent: Group
  # Only responses children.(non-hierarchically)
  children(codes: [ID!],type:GroupType, first: Int, last: Int, before: String, after:String): GroupConnection
  owner: Member
  isEditable: Boolean!
  productId: Int
  resourceId: Int
  # Only responses members in this group
  members(codes:[ID!],type: MemberType,first: Int, last: Int, before: String, after:String) : MemberConnection
  #APIs assigned to this group. Products have APIs.
  apis(codes: [ID!], first: Int, last: Int, before: String, after:String): APIConnection
  # Responses all groups in its group's childrens (hierarchically),
  managedGroups(codes: [ID!],type:GroupType, first: Int, last: Int, before: String, after:String): GroupConnection
  # Response all members in this group's childrens (hierarchically),
  allMembers(codes:[ID!],type: MemberType,first: Int, last: Int, before: String, after:String) : MemberConnection
  # Access resources in a group
  accesses(codes:[ID!], first: Int, last: Int, before: String, after:String): AccessConnection
  # Supplier resources in a group
  suppliers(codes:[ID!], accessID:[ID!], first: Int, last: Int, before: String, after:String): SupplierConnection
  # Clients resources in a group
  clients(codes:[ID!],name:[ID!],isActive:Boolean, first: Int, last: Int, before: String, after:String): ClientConnection
  # You can grant roles to members, which define the roles catalog for a group.
  roles(codes:[ID!], type:RoleType, first: Int, last: Int, before: String, after:String): RoleConnection
}

type GroupEdge {
  cursor: String!
  node: Group
}

# You grant access to members which can be either:
# Users: A developer, administrator or any other person from your Organization who interacts with the TravelgateX Platform. An email address can be used as the identity of a User.
# Service Accounts: An application (Client) instead of an individual User. If you prefer, you can create as many Service Accounts as needed to represent different logical components of your application.
type Member implements Node{
  code: ID!
  memberData: MemberData
  # Errors that abort services
  isActive: Boolean!
  error:   [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type MemberConnection{
  edges: [MemberEdge]
  pageInfo: PageInfo!
}

type MemberData {
  id: ID!
  code: ID!
  label: String
  # Member Type
  type: MemberType!
  # which groups the member is in?
  groups(codes:[ID!],type: GroupType,first: Int, last: Int, before: String, after:String) : GroupConnection
  # which roles the member has in?
  roles(codes: [ID!], type:RoleType, first: Int, last: Int, before: String, after:String): RoleConnection
}

type MemberEdge {
  cursor: String!
  node: Member
}

type Operation implements Node{
  code: ID!
  operationData: OperationData
  # Errors that abort services
  error: [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type OperationConnection{
  edges: [OperationEdge]
  pageInfo: PageInfo!
}

type OperationData{
  id: ID!
  code: ID!
  label: String
  types: [OperationType!]!
  api: API
}

type OperationEdge {
  cursor: String!
  node: Operation
}

# Organization node is the root node in the hierarachy, the folders are the children of the organization and the products are the children of the folders.
type Organization implements Node {
  code: ID!
  organizationData: OrganizationData
  # Errors that abort services
  error: [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type OrganizationConnection{
  edges: [OrganizationEdge]
  pageInfo: PageInfo!
}

type OrganizationData implements GroupCommonData {
  id: ID!
  code: ID!
  label: String
  type: GroupType!
  info: String
  # Only responses folders.(non-hierarchically)
  children(codes: [ID!], first: Int, last: Int, before: String, after:String): GroupConnection
  owner: Member
  isEditable: Boolean!
  members(codes:[ID!],type: MemberType,first: Int, last: Int, before: String, after:String) : MemberConnection
  #APIs assigned to this group. Products have APIs.
  apis(codes: [ID!], first: Int, last: Int, before: String, after:String): APIConnection
  # Products asign to a organization
  products(codes: [ID!], first: Int, last: Int, before: String, after:String): ProductConnection
  # Response all members in this group's childrens (hierarchically)
  allMembers(codes:[ID!],type: MemberType,first: Int, last: Int, before: String, after:String) : MemberConnection
  # Access resources in a organization
  accesses(codes:[ID!], first: Int, last: Int, before: String, after:String): AccessConnection
  # Supplier resources in a organization
  suppliers(codes:[ID!], accessID:[ID!], first: Int, last: Int, before: String, after:String): SupplierConnection
  # Clients resources in a organization
  clients(codes:[ID!],name:[ID!],isActive:Boolean, first: Int, last: Int, before: String, after:String): ClientConnection
}

type OrganizationEdge {
  cursor: String!
  node: Organization
}

# An APIs collection.
type Product implements Node{
  code: ID!
  productData: ProductData!
  # Errors that abort services
  error: [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type ProductConnection{
  edges: [ProductEdge]
  pageInfo: PageInfo!
}

type ProductData{
  id: ID!
  code: ID!
  label: String
  # A Product has many APIs
  apis(codes: [ID!], first: Int, last: Int, before: String, after:String): APIConnection
}

type ProductEdge {
  cursor: String!
  node: Product
}

# Resources are those used in APIs and Products.
type Resource implements Node{
  code: ID!
  resourceData: ResourceData
  # Errors that abort services
  error: [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type ResourceConnection{
  edges: [ResourceEdge]
  pageInfo: PageInfo!
}

type ResourceData{
  id: ID!
  code: ID!
  isEditable: Boolean!
  label: String
  # which API have asigned this resource?
  apis(codes: [ID!],first: Int, last: Int, before: String, after:String): APIConnection
  # which roles are asigned or are possibles in this resource?
  roles(codes: [ID!], type:RoleType, first: Int, last: Int, before: String, after:String): RoleConnection
}

type ResourceEdge {
  cursor: String!
  node: Resource
}

# Permissions determine what operations are allowed on a resource
type Role implements Node{
  code: ID!
  roleData: RoleData
  # Errors that abort services
  error: [Error!]
  # Date created
  createdAt: DateTime!
  # Date updated
  updatedAt: DateTime!
}

type RoleConnection{
  edges: [RoleEdge]
  pageInfo: PageInfo!
}

type RoleData{
  id: ID!
  code: ID!
  type: RoleType!
  isEditable: Boolean!
  label: String
  # Has resource Create permission?
  isCreate: Boolean!
  # Has resource Create permission?
  isRead: Boolean!
  # Has resource Update permission?
  isUpdate: Boolean!
  # Has resource Delete permission?
  isDelete: Boolean!
  # Is role enabled or not?
  isEnable: Boolean!
  # Has resource Executable permission?
  isExecutable: Boolean!
  # Has any other non-basic permission/s?
  isSpecial: Boolean!
  # Special permission
  special: String
  # Resources used
  resources(codes:[ID!],first: Int, last: Int, before: String, after:String): ResourceConnection
}

type RoleEdge {
  cursor: String!
  node: Role
}

# Indicates where it applies
enum ApplicationAreaType {
  # Apply at the hotel.
  HOTEL
  
  # Apply in the hotel.
  ROOM
  
  # Applies to a service.
  SERVICE
  
  # Applies in general.
  GENERAL
}

# Indicates the type of description
enum DescriptionType {
  # Additional Information
  ADDITIONAL
  
  # Amenities
  AMENITY
  
  # Activities
  ACTIVITY
  
  # Restaurants
  RESTAURANT
  
  # Rooms
  ROOM
  
  # General
  GENERAL
  
  # Pools
  POOL
  
  # Locations
  LOCATION
  
  # How to get
  HOW_TO_GET
}

# Indicates the type of destination
enum DestinationType {
  # Zone
  ZONE
  
  # City
  CITY
}

input HotelXBoardQueryInput {
  # Indicates the board codes that you want filter.
  boardCodes: [String!]
  # Indicates the access that you want use.
  access: ID!
}

input HotelXCategoryQueryInput {
  # Indicates the category codes that you want filter.
  categoryCodes: [String!]
  # Indicates the access that you want use.
  access: ID!
}

input HotelXDestinationListInput {
  # Indicates the access
  access:     ID!
  
  # Search by hotel codes
  destinationCodes:      [String!]
  
  # Maxium number of items per page
  maxSize:       Int
}

input HotelXDestinationSearcherInput {
    # Indicates the access
    access: ID!

    # Search by hotel name or destination name
    text: String!

    # Maxium number of items per type
    maxSize: Int
}
input HotelXHotelListInput {
  # Indicates the access
  access:     ID!
  
  # Search by hotel codes
  hotelCodes:      [String!]
  
  # Search by destination codes, only search by minimal destinations
  destinationCodes: [String!]
  
  # Filter by supplier rank
  ranks:      [Int!]
  
  # Maxium number of items per page
  maxSize:       Int
}

input HotelXRoomQueryInput {
  # Indicates the room codes that you want filter.
  roomCodes: [String!]
  # Indicates the access that you want use.
  access: ID!
}

#An Amenity is defined as something intended to make life more pleasant or comfortable for people. Examples include: swimming pools, shopping centers, etc.
type Amenity {
  # Code
  code: String!

  # Indicates the type of Amenity.
  type: ApplicationAreaType!

  # Contains the descriptive
  texts(languages: [Language!]): [Text!]!
}

# Board type.
type Board implements Node {
  # Board ID
  code: ID!

  # Board data
  boardData: BoardData

  # Errors that abort services
  error: [Error!]

  # Date created
  createdAt: DateTime!

  # Date updated
  updatedAt: DateTime!
}

# BoardList definition
type BoardConnection {
  edges: [BoardEdge]
  # Indicates info about page
  pageInfo: PageInfo!
}

# Board data
type BoardData {
  # Internal code for checking availability
  code: ID!
  
  # Code of the hotel in the Supplier selected
  boardCode: String!
  
  # Label
  texts(languages: [Language!]): [Text!]
}

# BoardList Edge definition
type BoardEdge {
  cursor: String!
  node: Board
}

# Category Type
type Category implements Node {
  # Category ID
  code: ID!
  
  # Category data
  categoryData: CategoryData
  
  # Errors that abort services
  error: [Error!]
  
  # Date created
  createdAt: DateTime!
  
  # Date updated
  updatedAt: DateTime!
}

# CategoryList definition
type CategoryConnection {
  edges: [CategoryEdge]
  # Indicates info about page
  pageInfo: PageInfo!
}

# Category data
type CategoryData {
  # Internal code for checking availability
  code: ID!

  # Code of the hotel based on the Supplier selected
  categoryCode: String!

  # Label
  texts(languages: [Language!]): [Text!]
}

# CategoryList Edge definition
type CategoryEdge {
  cursor: String!
  node: Category
}

# Contact Data.
type Contact {
  # Email
  email: String
  
  # Telephone
  telephone: String
  
  # Fax
  fax: String
  
  # Web
  web: URI
}

# Geographical coordinates corresponding to a location.
type Coordinates {
  # Latitude
  latitude: Float!
  
  # Longitude
  longitude: Float!
}

# Object description indicates the type and the description about something.
type Description {
  # Indicates type of description
  type: DescriptionType!
  
  # Label
  texts: [Text!]
}

# Destination Type
type Destination implements Node {
  # Destination ID
  code: ID!
  
  # Destination data
  destinationData: DestinationData
  
  # Errors that abort services
  error: [Error!]
  
  # Date created
  createdAt: DateTime!
  
  # Date updated
  updatedAt: DateTime!
}

# DestinationList definition
type DestinationConnection {
  edges: [DestinationEdge]
  token: String!
  # Indicates info about page
  pageInfo: PageInfo!
}

# Information about destinantion
type DestinationData {
  # Destination Code
  code: ID!
  
  # Indicates if you can search by destination
  available: Boolean!
  
  # Returns destination leafs of the destination.
  destinationLeaf: [String!]
  
  # Contains the destination name
  texts(languages: [Language!]): [Text!]!
  
  # Closest destinations, indicates destinations in proximity
  closestDestinations: [String!]
  
  # Parent destination code
  parent: String
  
  # Indicates destination type, zone or city
  type: DestinationType
}

# DestinationList Edge definition
type DestinationEdge {
  cursor: String!
  node: Destination
}

union DestinationSearchResult = HotelData | DestinationData
# Hotel Type
type Hotel implements Node {
  # Hotel ID
  code: ID!
  
  # Hotel data
  hotelData: HotelData
  
  # Errors that abort services
  error: [Error!]
  
  # Date created
  createdAt: DateTime!
  
  # Date updated
  updatedAt: DateTime!
}

# HotelList definition
type HotelConnection {
  edges: [HotelEdge]
  token: String
  # Indicates info about page
  pageInfo: PageInfo!
}

# Hotel data
type HotelData {
  # Internal code.
  code: ID!
  
  # Code to perform availability.
  hotelCode: String!
  
  # Native supplier hotel code.
  hotelCodeSupplier: String
  
  # Name of the hotel in the Supplier selected.
  hotelName: String!
  
  # Hotel category (for example number of stars).
  categoryCode: String!
  
  # Indicates property type
  property: Property
  
  # Hotel chain code
  chainCode: String
  
  # Indicates that the Hotel has an Exclusive Deal.
  exclusiveDeal: Boolean!
  
  # Indicates the location of the hotel
  location: Location!
  
  # Contact cotains information about hotel contact.
  contact: Contact
  
  # Rank indicates the supplier categorization.
  rank: [Int!]!
  
  # List of credit cards
  cardTypes: [String!]
  
  # Amenities
  amenities: [Amenity!]
  
  # Medias
  medias: [Media!]
  
  # Descriptions
  descriptions(types: [DescriptionType!], languages: [Language!]): [Description!]
}

# HotelList Edge definition
type HotelEdge {
  cursor: String!
  node: Hotel
}

# Indicates the location of the hotel
type Location {
  # Contains Hotel Address
  address: String
  
  # Contains the city
  city: String
  
  # Contains the zipCode.
  zipCode: String
  
  # Country where is the Hotel.
  country: Country!
  
  # Geographical coordinates corresponding to a location.
  coordinates: Coordinates
  
  # Closest destination
  closestDestination: DestinationData!
}

# Contains media information.
type Media {
  # Code.
  code: String
  
  # Indicates the order priority.
  order: String
  
  # Indicates the type of the media.
  type: ApplicationAreaType!
  
  # Date updated.
  updatedAt: DateTime!
  
  # Url.
  url: URI!
  
  # Contains the descriptive.
  texts(languages: [Language!]): [Text!]
}

# Indicates Property type
type Property {
  # Indicates property type
  name: String
  
  # Indicates property type code
  code: String
}

# RoomList definition
type RoomConnection {
  edges: [RoomEdge]
  # Indicates info about page
  pageInfo: PageInfo!
}

# Room data
type RoomData {
  # Internal code for checking availability
  code: ID!
  
  # Code of the hotel in the Supplier selected
  roomCode: String!
  
  # Label
  texts(languages: [Language!]): [Text!]
}

# RoomList Edge definition
type RoomEdge {
  cursor: String!
  node: RoomStatic
}

# Room Type
type RoomStatic implements Node {
  # Room ID
  code: ID!
  
  # Room data
  roomData: RoomData
  
  # Errors that abort services
  error: [Error!]
  
  # Date created
  createdAt: DateTime!
  
  # Date updated
  updatedAt: DateTime!
}

# Indicates the type of criteria in the request of the booking list
enum BookingCriteriaType {
  # Search by date range
  DATES
  
  # Search by reference codes
  REFERENCES
}

# Book status
enum BookStatusType {
  # The reservation was completed with no problems
  OK
  
  # The status of the booking is KO
  KO
  
  # The reservation was completed but the product is still not available, so the reservation goes into a waiting list.
  # It is the client’s responsibility to check if the booking is OK
  ON_REQUEST
  
  # The status of the booking is cancelled
  CANCELLED
  
  # The reservation was completed but due to a supplier error or a timeout, the reservation status is unknown.
  # It is the client’s responsibility to check if the booking is OK
  UNKNOWN
}

# Business rules type
enum BusinessRulesType {
  # The cheapest options is returned without exceeding the optionsQuota limit.
  CHEAPER_AMOUNT
  
  # Groups the option by room type without exceeding the optionsQuota limit.
  ROOM_TYPE
}

# Options type
enum CancelPenaltyType {
  # Indicates the number of nights to be penalized.
  NIGHTS
  
  # Indicates the percentage to pay based on the option price.
  PERCENT
  
  # Indicates the exact amount payable.
  IMPORT
}

# Charge Type
enum ChargeType {
  # The charge is included.
  INCLUDE
  
  # The charge is excluded.
  EXCLUDE
}

# Duration Type
enum DurationType {
  # Date range is set.
  RANGE
  
  # Not restricted by date.
  OPEN
}

# Indicates what type of value is the markup, by percentage or is an import.
enum MarkupRuleType {
  # Indicates the percentage applied by a rule.
  PERCENT
  
  # Indicates the exact amount applied by a rule.
  IMPORT
}

# Plugin Step Type. https://docs.travelgatex.com/hotelx/plugins/overview/
enum PluginStepType {
  # Plugins executed after Buyer requests message to HotelX
  REQUEST
  
  # Plugins executed before sending request to Supplier using Access and after Accesses have been calculated
  REQUEST_ACCESS
  
  # Plugins executed after Supplier responds message. For every option returned
  RESPONSE_OPTION
  
  # Plugins executed after all Access options has been responded
  RESPONSE_ACCESS
  
  # Plugins executed before HotelX responds message to to Buyer
  RESPONSE
}

# Plugin Type. https://docs.travelgatex.com/hotelx/plugins/overview/
enum PluginType {
  # PRE_STEP is the first plugin that a step will execute, allows a full range of operations:
  # split arrays, join arrays, modify object values, add or remove object instances
  PRE_STEP
  
  # HOTEL_MAP allows to match Seller and Buyer hotel codes based on contexts
  HOTEL_MAP
  
  # BOARD_MAP allows to match Seller and Buyer board codes based on contexts
  BOARD_MAP
  
  # ROOM_MAP allows to match Seller and Buyer room codes based on contexts
  ROOM_MAP
  
  # CURRENCY_CONVERSION allows to match Seller and Buyer hotel codes based on contexts
  CURRENCY_CONVERSION
  
  # MARKUP allows to apply markup over price
  MARKUP
  
  # AGGREGATION allows to aggregate multiple supplier options
  AGGREGATION
  
  # POST_STEP is the last plugin that a step will execute, allows a full range of operations:
  # split arrays, join arrays, modify object values, add or remove object instances
  POST_STEP
}

# Price Type
enum PriceType {
  # Price without deductions.
  GROSS
  
  # Price after deducting all discounts and rebates.
  NET
  
  # Final quantity. Sum of multiple quantities.
  AMOUNT
}

# Service Type
enum ServiceType {
  # A ticket or pass authorizing the holder to ski in a certain place or resort. Gross.
  SKI_PASS
}

# Indicartes options status
enum StatusType {
  # The status of the avail is available
  OK
  
  # The status of the avail is On request
  RQ
}

# Supplement Type
enum SupplementType {
  # A ticket or pass authorizing the holder to ski in a certain place or resort.
  SKI_PASS
  
  # Lessons of any type that the costumer can take.
  LESSONS
  
  # Supplement of a determined meal plan.
  MEALS
  
  # Extra equipment for a specific purpose.
  EQUIPMENT
  
  # Admission to some service.
  TICKET
  
  # Transfers used by the costumer.
  TRANSFERS
  
  # Gala: A festive occasion, celebration or special entertainment.
  GALA
  
  # Activities that the costumer can do.
  ACTIVITY
}

# Unit Time Type
enum UnitTimeType {
  # Day
  DAY
  
  # Hour
  HOUR
}

# The information required to access the supplier's system.
input AccessConfigurationInput {
  # Indicates if Access is active
  isActive: Boolean!
  # Arbitrary not unique identifier
  code: String!
  # Supplier to which this access belongs
  supplier: String!
  # Information required to access the supplier's system.
  configuration: ConfigurationInput
}

# Connect user input for data access management API
input AccessConnectUserInput {
  # connect user code
  code: String!
  # Indicates if the connect user is active.
  isActive: Boolean!
  # groups related to this connect user
  groups: [ConnectUserGroupInput!]
}

# Include *OR* exclude accesses in this specific search query. If not specified, default accesses will be used.
# Only one list (includes or excludes) *MUST* be used.
input AccessFilterInput {
  # These Access IDs will overwrite the default configuration. Only the IDs on this list will be used in the search query.
  includes: [ID!]
  
  # These Access IDs will overwrite the default configuration. The IDs on this list will be excluded from the search query.
  excludes: [ID!]
}

# Supplier input for data access management API
input AccessSupplierInput {
  # supplier code
  code: String!
  # supplier instance
  dll: String!
  # Indicates if the supplier is active.
  isActive: Boolean!
  # groups related to this supplier
  groups: [SupplierGroupInput!]
}

# Input BookPax contains basic information abaout pax suach as name, surname and age.
input BookPaxInput {
  # The guest's first  name
  name: String!
  
  # The guest's last name
  surname: String!
  
  # The guest's age
  age: Int!
}

# Reference object that contains the client reference and/or supplier reference.
input BookReferenceInput {
  # The client's reference
  client: String
  
  # The Supplier's reference
  supplier: String
}

# Input BookRoom contains list of pax and the room's reference.
input BookRoomInput {
  # The room's reference in the booking
  occupancyRefId: Int!
  
  # The list or lists of paxes of the room
  paxes: [BookPaxInput!]!
}

# List of business rules to use as filter on the options.
input BusinessRulesInput {
  # Options quota per search. Maximum numbers of options to be returned by the search query.
  optionsQuota: Int
  
  # Different business rules to filter the returned options.
  businessRulesType: BusinessRulesType
}

# The information and credentials required to access the supplier’s system.
input ConfigurationInput {
  # User name for the connection.
  username: String
  
  # Password for the connection
  password: String
  
  # URL or endpoint for the connection.
  urls:           UrlsInput!
  
  # List of parameters with additional required information.
  parameters: [ParameterInput!]
  
  # Source Markets allowed for the Access
  markets: [String!]
  
  # RateRules allowed for the access.
  rateRules: [RateRulesType!]
}

# group related to a connect user
input ConnectUserGroupInput {
  # Group code of the group related to this connected user
  groupCode: String!
  # Indicates if the connect user is active for its connected user
  isActive: Boolean!
}

# Criteria by dates
input CriteriaBookingDatesInput {
  # Type of date. Can be Arrival or Booking date.
  dateType: DateType!
  
  # Start date.
  # Format: YYYY-MM-DD.
  start: Date!
  
  # End date.
  # Format: YYYY-MM-DD.
  end: Date!
}

# Criteria by references
input CriteriaBookingReferencesInput {
  # The hotel code.
  hotelCode: String!
  
  # The requested currency. The API will convert to this currency if supplier returns a different one.
  currency : Currency!
  
  # Contains the client reference and/or supplier reference.
  references: [BookReferenceInput!]!
}

# Input delta price, indicates the price variation permitted by the client before failing the booking.
input DefaultSettingsBusinessRulesInput {
  # Options quota per availability; numbers of options based on availability
  optionsQuota: Int!
  
  # Different business rules for filtering options that you are interested in
  businessRulesType: BusinessRulesType!
}

input DefaultSettingsInput {
  # Unique Id
  groupCode : String!
  
  # This field is occurs only if the authorization header is of the type JWT.. It is used for to change the user that
  # has been set by default in the preload.
  connectUser: String!
  
  # Indicates the context of the I/O codes (hotel, board, room and rates)
  context: String
  
  # Language to be used in request
  language : Language!
  
  # Currency requested if supported by supplier
  currency : Currency!
  
  # Nationality of the guest (use ISO3166_1_alfa_2)
  nationality : Country!
  
  # Targeted zone, country or point-ofsale-to be used in request.
  market : String!
  
  # Group of timeouts to be used in the differents services
  timeout : TimeoutInput!
  
  # Business rules
  businessRules: DefaultSettingsBusinessRulesInput!
}

# Input delta price, indicates price variation permitted by the client
# An error will be returned if the new price does not abide to DeltaPrice. If DeltaPrice is not sent and the integration implements it, we assume that the price range is 0 and the process will continue 
# (price is lower or equal to the price showed in valuation).
# This field is implemented if it’s native to the supplier or if another availability/valuation request needs to be done in Reservation. In case the supplier blocks the option in valuation, reservation 
# will be done automatically in reservation method.
input DeltaPriceInput {
  # The amount in the currency returned by the option that will be accepted by the client to be higher than the valuation price.
  amount: Float
  
  # The percentage accepted by the client to be higher than the valuation price.
  percent: Float
  
  # Depending on the value of applyBoth:
  # applyBoth = false: Indicates that one of the conditions (amount or percentage) has to meet the criteria before reservation.
  # applyBoth = true: Indicates that the new price cannot exceed the amount or percentage indicated by the client.
  applyBoth: Boolean!
}

# The card expiration date
input ExpireDateInput{
  # Month MM
  month: Int!
  
  # Year yy
  year: Int!
}

# Filter that selects the filter criteria which will be used in this availability. Currently you can only choose the accesses.
# You must choose one of them, include or exclude, or the other alternative isn't specified anything.
# If input both, you will receive a validation error that indicates this error.
input FilterInput {
  # You can specify one of the filters or any of them. In this latter case, all the configurated accesses will be executed.
  access: AccessFilterInput
  
  # If requested, only options with the specified rateRules will be returned
  rateRules: RateRulesFilterInput
}

input GroupAccessInput {
  # groups identifiers in which the access will be associated
  groupCodes: [String!]
  # access related data
  accesses: [AccessConfigurationInput!]!
}

# Holder object that contains the occupant's (pax's) name and surname.
input HolderInput {
  # The card holder's name
  name: String!
  
  # The card holder's surname
  surname: String!
}

# Criteria of book.
input HotelBookInput {
  # Option ID
  optionRefId: String!
  
  # Language to be used in request
  language: Language
  
  # Booking ID in client's system.
  clientReference: String!
  
  # Indicates price variation permitted by the client.
  deltaPrice: DeltaPriceInput
  
  # If the payment is done by credit card, it's mandatory to specify the payment type and the credit card information.
  paymentCard: PaymentCardInput
  
  # Any customer comments for the supplier to consider.
  remarks: String
  
  # Holder's basic information.
  holder: HolderInput!
  
  # Rooms within this option.
  rooms: [BookRoomInput!]!
}

# Cancellation Criteria.
input HotelCancelInput {
  # The name of the access to use in the request.
  accessCode: String!
  
  # The language code.
  language: Language
  
  # The hotel code.
  hotelCode: String!
  
  # Contains the client reference and/or supplier reference.
  # One of them is mandatory.
  reference: BookReferenceInput!
}

# Criteria of book contains basic information to find a book or books.
input HotelCriteriaBookingInput {
  # Name of the access that have to use in the request.
  accessCode: String!
  
  # The language code.
  language: Language
  
  # The search type criteria.
  typeSearch: BookingCriteriaType!
  
  # The references criteria.
  references: CriteriaBookingReferencesInput
  
  # The dates criteria.
  dates: CriteriaBookingDatesInput
}

# The quote criteria contains the option reference id, block and language.
input HotelCriteriaQuoteInput {
  # Identifier of the option chosen in the search.
  optionRefId: String!
  
  # Language to be used in request
  language : Language
}

# Search criteria contains destination, travel dates and the number of pax in each room.
# You must preload the other fields in our system by complete the fields absents.
input HotelCriteriaSearchInput {
  # Check-in date for booking
  # Format: YYYY-MM-DD
  checkIn: Date!
  
  # Check-out, booking date
  # Format: YYYY-MM-DD
  checkOut: Date!
  
  # Hotel Codes.
  hotels: [String!]

  # Destination codes.
  destinations: [String!]
  
  # For multi-room bookings, this array will contain multiple elements (rooms).
  # For each room you have to specify its own occupancy.
  occupancies: [RoomInput!]!
  
  # Language to be used in request
  language : Language
  
  # Currency requested if supported by supplier
  currency : Currency
  
  # Nationality of the guest (use ISO3166_1_alfa_2)
  nationality : Country
  
  # Targeted zone, country or point-ofsale-to be used in request.
  market : String
}

# Settings that you can edit for this avail. Values are loaded by default in our Back Office.
input HotelSettingsInput {
  # Indicates the context of the I/O codes (hotel, board, room and rates)
  context: String
  
  #Indicates if you want use context, or not, by default is true.
  #@deprecated(reason: "deprecated from 2017-12-12. Redundant.")
  useContext: Boolean
  
  # This field is occurs only if the authorization header is of the type JWT.. It is used to change the user that has been set by default in the preload.
  #@deprecated(reason: "deprecated from 2018-03-19. Redundant.")
  connectUser: String
  
  # This field is occurs only if the authorization header is of the type JWT.. It is used to change the user that has been set by default in the preload.
  client: String
  
  # Group whose resources want to be used
  group: String
  
  # Milliseconds before the connection is closed.
  timeout: Int
  
  # Returns all the transactions exchanged with the supplier.
  auditTransactions: Boolean
  
  # Business rules
  businessRules: BusinessRulesInput
  
  # Array of suppliers. Each one contains its own code, settings and accesses.
  suppliers: [HotelXSupplierInput!]
  
  # Array of plugins to execute.
  plugins: [PluginStepInput!]

  # This flag allows only the accesses checked as test. By default is production.
  testMode: Boolean
}

# AccessInput overwrites an existent access in our Back Office or creates a new
# one to be used in this search query only. An access object contains its own code, configuration and settings.
input HotelXAccessInput {
  # The accessID used to identify the existing access in our Back Office in order to
  # overwrite it. Acts as an identifier in this search. It can either exist or not.
  accessId: ID!
  
  # Information required to access the supplier's system.
  configuration: ConfigurationInput
  
  # You can configure an special settings for any access. This level overwrites the search and supplier settings levels.
  settings: SettingsBaseInput
}

# Supplier object. Contains its own settings, code and access.
input HotelXSupplierInput {
  # You can configure an special settings for any supplier. This level overwrites the avail settings level but not the
  # access settings level.
  settings: SettingsBaseInput
  
  # Code that represents a supplier in our system.
  # This information is mandatory.
  code: String!
  
  # Array of accesses that can overwrite an existing access information or include a new access for this avail.
  accesses: [HotelXAccessInput!]
}

input IdAccessConfigurationInput {
  # access unique identifier
  id: ID!
  # Indicates if Access is active
  isActive: Boolean!
  # Arbitrary not unique identifier
  code: String!
  # Supplier to which this access belongs
  supplier: String!
  # Information required to access the supplier's system.
  configuration: ConfigurationInput
}

input IdGroupAccessInput {
  # identifier of the groups in which the access will be associated
  groupCodes: [String!]
  
  accesses: [IdAccessConfigurationInput!]!
}

# Pax object that contains the pax age.
input PaxInput {
  # Pax age.
  age: Int!
}

# Input PaymentCard, if the payment is done by credit card, is it mandatory to specify the payment type and the credit card information
input PaymentCardInput {
  # Indicates the card type.
  cardType: String!
  
  # Contains owner's name
  holder: HolderInput!
  
  # Contains credit card number
  number: String!
  
  # Contains credit card CVC
  CVC: String!
  
  # Contains credit card expiration date
  expire: ExpireDateInput!
}

# Plugin to execute.
input PluginsInput {
  # type of the plugins to execute
  type: PluginType!
  
  # name of plugin to execute
  name: String!
  
  # Plugin's parameters
  parameters: [ParameterInput!]
}

# Plugin to execute.
input PluginStepInput {
  # Indicates where the plugin will be executed.
  step: PluginStepType!
  
  # Indicates the plugin that will be executed.
  pluginsType: [PluginsInput!]
}

# If requested, only options with the specified rateRules will be returned
input RateRulesFilterInput {
  # if includes not nil: only options without rate rules and options with rate rules found in includes will be returned
  includes: [RateRulesType!]
  
  # if excludes not nil: only options without rate rules and options with rate rules that haven't been sent in excludes will be returned
  excludes: [RateRulesType!]
}

# Occupancy for a room. It contains a list of pax ages.
input RoomInput {
  # Array of pax ages. The number of items in the array will indicate the pax occupancy.
  paxes: [PaxInput!]!
}

# Contains the time out and business rules of a supplier or an access.
input SettingsBaseInput {
  # Milliseconds before the connection is closed.
  timeout: Int
  
  # Specifies if transactions exchanged with the supplier have to be logged or not.
  auditTransactions: Boolean
  
  # Business rules
  businessRules: BusinessRulesInput
}

# group related to a supplier
input SupplierGroupInput {
  # group code of the group related to this supplier
  groupCode: String!
  # Indicates if the supplier is active for its supplier
  isActive: Boolean!
}

input TimeoutInput {
  # Milliseconds before the search connection is closed.
  search: Int!
  
  # Milliseconds before the quote connection is closed.
  quote: Int!
  
  # Milliseconds before the book connection is closed.
  book: Int!
}

interface BookableOptionSearch {
  # Supplier that offers this option.
  supplierCode: String!
  
  # Access code of this option.
  accessCode: String!
  
  # Indicates the id to be used on Quote as key
  id: String!
}

interface Priceable {
  # Specifies the currency.
  currency: Currency!
  
  # Is binding.
  binding: Boolean!
  
  # Specifies the import net.
  net: Float!
  
  # Specifies the import gross.
  gross: Float
  
  # Specifies the exchange.
  exchange: Exchange!
}

interface Response {
  # Application stats
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier’s original format.
  auditData: AuditData
  
  # Errors that lead the service to stop
  errors: [Error!]
  
  # Potentially harmful situations or errors that do not stop the service
  warnings: [Warning!]
}

# Additional information about the option
type AddOn {
  # Contains keyword/ID to identify the AddOn.
  key: String!
  
  # Contains AddOn values.
  value: JSON!
}

# Additional information about the option
type AddOns {
  # Extra information from the distribution layer
  distribute: JSON @deprecated(reason: "You can find it in distribution AddOn")
  
  # Extra information from the distribution layer
  distribution: [AddOn!]
}

# Data sent and received in the supplier’s native format.
type AuditData {
  # List of transactions data
  transactions:    [Transactions!]!
  
  # TimeStamp
  timeStamp:       DateTime!
  
  # Process time in milliseconds (ms)
  processTime:     Float!
}

# Contains information about a bed.
type Bed {
  # Specifies the bed type
  type: String
  
  # Description about the bed
  description: String
  
  # Indicates number of beds in a room
  count: Int
  
  # Specifies if the bed is shared or not
  shared: Boolean
}

# Returns detailed information about books.
type Booking {
  # Returns detailed information about books, you can indicated a list of locators or a range date.
  hotel(criteria: HotelCriteriaBookingInput!, settings: HotelSettingsInput): HotelBooking @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
}

type BookingHotel {
  # Creation date of the booking.
  # Format: YYYY-MM-DD
  creationDate: Date
  
  # Check-in date for booking
  # Format: YYYY-MM-DD
  checkIn: Date
  
  # Check-out date for the booking.
  # Format: YYYY-MM-DD
  checkOut: Date
  
  # Code of the hotel in the context selected.
  hotelCode: String
  
  # Name of the hotel.
  hotelName: String
  
  # Code of the board in the context selected.
  boardCode: String
  
  # List of occupancies for the request
  occupancies: [Occupancy!]
  
  # List of rooms.
  rooms: [BookingRoom!]
}

type BookingRoom {
  # ID reference to the occupancy
  occupancyRefId: Int
  
  # Indicates the room code
  code: String
  
  # Description about the room
  description: String
  
  # Total price for all days.
  price: Price
}

# List of business rules for filtering options based on your interests.
type BusinessRules {
  # Options quota per availability; numbers of options based on availability
  optionsQuota: Int!
  
  # Different business rules for filtering options that you are interested in
  businessRulesType: BusinessRulesType!
}

# Contains information for cancellation penalities..
type CancelPenalty {
  # Cancellation fees applicable X number of hours before the check-in date
  hoursBefore: Int!
  
  # Type of penalty; this can be Nights, Percent or Import
  penaltyType: CancelPenaltyType!
  
  # Currency used in the cancellation policy
  currency: Currency!
  
  # Value of the cancellation policy
  value: Float!
}

# Information about a policy cancellation.
type CancelPolicy {
  # Indicates if the option is refundable or non-refundable
  refundable: Boolean!
  
  # List of cancellation penalties
  cancelPenalties: [CancelPenalty!]
}

# Data related to a connected user and its groups
type ConnectUser {
  # Unique connected user of a supplier
  code: String!
  # Indicates whether a connected user is active
  isActive: Boolean!
  # Connected user's related data based on its groups
  connectUserGroups: [ConnectUserGroup!]
}

# group related to a connect user
type ConnectUserGroup {
  # Group code of the group related to this connected user
  groupCode: String!
  # Indicates if the connect user is active for its connected user
  isActive: Boolean!
}

# Search criteria contains destination, travel dates and the number of pax in each room.
type CriteriaSearch {
  # Check-in date for booking
  # Format: YYYY-MM-DD
  checkIn: Date!
  
  # Check-out, booking date
  # Format: YYYY-MM-DD
  checkOut: Date!
  
  # Contains the list of hotels's ID
  hotels: [String!]!
  
  # For multi-room bookings, this array will contain multiple elements (rooms).
  # For each room you have to specify its own occupancy.
  occupancies: [RoomCriteria!]!
  
  # Language to be used in request
  language : Language
  
  # Currency requested if supported by supplier
  currency : Currency
  
  # Nationality of the guest (use ISO3166_1_alfa_2)
  nationality : Country
  
  # Targeted zone, country or point-ofsale-to be used in request.
  market : String!
}

type DefaultSettings {
  # This field is occurs only if the authorization header is of the type JWT.. It is used for to change the user that
  # has been set by default in the preload.
  connectUser: String
  
  # Indicates the context of the I/O codes (hotel, board, room and rates)
  context: String
  
  # Language to be used in request
  language : Language!
  
  # Currency requested if supported by supplier
  currency : Currency!
  
  # Nationality of the guest (use ISO3166_1_alfa_2)
  nationality : Country!
  
  # Targeted zone, country or point-ofsale-to be used in request.
  market : String
  
  # Group of timeouts to be used in the differents services
  timeouts : Timeout!
  
  # Business rules
  businessRules: BusinessRules!
}

# Provides information about the currency of original, and its rate applied over the results returned by the Supplier.
type Exchange {
  # Provide information about the currency of origin
  currency: Currency!
  
  # Provides information about the rate applied over results
  rate: Float!
}

# Pairs of Groups and Accesses. All Accesses returned will belong to all the Groups in groupCodes.
type GroupAccess {
  # Group identifiers
  groupCodes: [String!]!
  
  accesses: [Access!]
}

# Holder object that contains the occupant's (pax's) name and surname.
type Holder {
  # Holder's name
  name: String!
  
  # Holder's surname
  surname: String!
}

type HotelBooking implements Response {
  # Application stats in string format
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier's native format.
  auditData: AuditData
  
  # Details about booking
  bookings: [HotelBookingDetail!]
  
  # Errors that abort services
  errors: [Error!]
  
  # Potentially harmful situations or errors, but ones that will not forcibly abort the service
  warnings: [Warning!]
}

# Contains information about booking
type HotelBookingDetail {
  # Booking ID in the Supplier's system
  reference: Reference!
  
  # Holder's name and surname
  holder: Holder
  
  # Information about the hotel.
  hotel: BookingHotel
  
  # Specifies the prices (Gross, Net and Amount) of the option returned.
  price: Price
  
  # Specifies cancel policies of the book returned.
  cancelPolicy: CancelPolicy
  
  # Additional information about the book.
  remarks: String
  
  # Booking Status.
  status: BookStatusType!
  
  # Payable.
  payable: String
  
  # Additional information about the option
  addOns: AddOns
}

type HotelBookPayload implements Response {
  # Application stats in string format
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier's native format.
  auditData: AuditData
  
  # Information about booking
  booking: HotelBookingDetail
  
  # Errors that abort services
  errors: [Error!]
  
  # Potentially harmful situations or errors, but ones that will not forcibly abort the service
  warnings: [Warning!]
}

# Contains information about cancel
type HotelCancelDetail {
  # Booking ID in the Supplier's system
  reference: Reference
  
  # Cancellation ID in the Supplier's system
  cancelReference: String
  
  # Booking Status.
  status: BookStatusType
  
  # Specifies the prices (Gross, Net and Amount) of the cancellation.
  price: Price
  
  # Information about the booking.
  booking: HotelBookingDetail
}

type HotelCancelPayload implements Response {
  # Application stats in string format
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier's native format.
  auditData: AuditData
  
  #Information about cancel
  cancellation: HotelCancelDetail
  
  # Errors that abort services
  errors: [Error!]
  
  # Potentially harmful situations or errors, but ones that will not forcibly abort the service
  warnings: [Warning!]
}

# Contains information about quote(s)
type HotelOptionQuote {
  # Indicates the valuation key
  optionRefId: String!
  
  # The possible values in status in response are Available (OK) or On Request (RQ).
  status: StatusType!
  
  # Specifies the prices (Gross, Net and Amount) of the option returned.
  price: Price!
  
  # Specifies cancel policies of the option returned.
  cancelPolicy: CancelPolicy!
  
  # Additional information about the option.
  remarks: String
  
  # List of surcharges of the option returned.
  surcharges: [Surcharge!]
  
  # List of credit cards
  cardTypes: [String!]
  
  # Additional information about the option
  addOns: AddOns
}

# An option includes hotel information, meal plan, total price, conditions and room description
type HotelOptionSearch implements BookableOptionSearch {
  # Supplier that offers this option.
  supplierCode: String!
  
  # Access code of this option.
  accessCode: String!
  
  # Market of this option.
  market: String!
  
  # Code of the hotel in the context selected.
  hotelCode: String!
  
  # Supplier's hotel code.
  hotelCodeSupplier: String!
  
  # Name of the hotel.
  hotelName: String
  
  # Code of the board in the context selected.
  boardCode: String!
  
  # Supplier's board code.
  boardCodeSupplier: String!
  
  # Indicates the payment type of the option returned. Possible options: Merchant, Direct, Card Booking, Card check in and Mixed.
  paymentType: PaymentType!
  
  # The possible values in status in response are Available (OK) or On Request (RQ).
  status: StatusType!
  
  # List of occupancies for the request
  occupancies: [Occupancy!]!
  
  # List of rooms of the option returned.
  rooms: [Room!]!
  
  # Specifies the prices (Gross, Net and Amount) of the option returned.
  price: Price!
  
  # List of supplements of the option returned.
  supplements: [Supplement!]
  
  # List of surcharges of the option returned.
  surcharges: [Surcharge!]
  
  # Specifies rate rules of the option returned.
  rateRules: [RateRulesType!]
  
  # Specifies cancel policies of the option returned.
  cancelPolicy: CancelPolicy
  
  # Additional information about the option.
  remarks: String
  
  # Additional information about the option
  addOns: AddOns
  
  # Token for Deep Link
  token: String!
  
  # Indicates the quote key
  id: String!
}

type HotelQuote implements Response {
  # Application stats in string format
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier's native format.
  auditData: AuditData
  
  # Information about quote.
  optionQuote: HotelOptionQuote
  
  # Errors that abort services
  errors: [Error!]
  
  # Potentially harmful situations or errors, but ones that will not forcibly abort the service
  warnings: [Warning!]
}

# Results from Avail Hotel; contains all the available options for a given date and itinerary
type HotelSearch implements Response {
  # Indicates the context of the response.
  context: String
  
  # Application stats in string format
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier's native format.
  auditData: AuditData
  
  # Request Criteria
  requestCriteria: CriteriaSearch
  
  # List of options returned according to the request.
  options: [HotelOptionSearch!]
  
  # Errors that abort services
  errors: [Error!]
  
  # Potentially harmful situations or errors that won't force the service to abort
  warnings: [Warning!]
}

# Map codes.
type Map {
  # Context code.
  code: String!
  # Equivalences of the supplier for the client code.
  maps: [String!]
}

# Returns the mapping for a group.
type Mapping {
  # Returns the differents group contexts, you can filter by some contexts.
  contexts(codes: [String!]): [MappingContext!]
  
  # Errors that abort services
  errors: [Error!]
  
  # Potentially harmful situations or errors that won't force the service to abort
  warnings: [Warning!]
}

# Returns the differents group contexts
type MappingContext {
  # Code of the context
  code: String!
  # Mapping of hotels, you can filter by hotel code.
  hotels(codes: [String!]): [MappingEntity!]
  # Mapping of rooms, you can filter by room code.
  rooms(codes: [String!]): [MappingEntity!]
  # Mapping of boards, you can filter by board code.
  boards(codes: [String!]): [MappingEntity!]
}

# Mapping about client codes with the equivalence per supplier.
type MappingEntity {
  # Client code
  code: String!
  # You can filter by output context.
  contexts(codes: [String!]): [Map!]
}

# Informs markup applied over supplier price.
type Markup implements Priceable {
  #channel of markup application.
  channel: String
  
  # Currency code indicating which currency should be paid.
  # This information is mandatory.
  currency: Currency!
  
  # It indicates if the price indicated in the gross must be respected.
  # That is, the customer can not sell the room / option at a price lower than that established by the supplier.
  # This information is mandatory.
  binding: Boolean!
  
  # Indicates the net price that the customer must pay to the supplier plus the markup.
  # This information is mandatory.
  net: Float!
  
  # Indicates the retail price that the supplier sells to the customer plus the markup.
  gross: Float
  
  # Informs about the currency of origin, and the rate applied over result.
  # This information is mandatory.
  exchange: Exchange!
  
  # Breakdown of the applied rules for a markup
  rules: [Rule!]!
}

# Information about occupancy.
type Occupancy {
  # Unique ID room in this option.
  id: Int!
  
  # List of pax of this occupancy.
  paxes: [Pax!]!
}

# Specifies the age pax. The range of what is considered an adult, infant or baby is particular to each supplier.
type Pax {
  # Specifies the age pax.
  age: Int!
}

# Price indicates the value of the room/option.
# Supplements and/or surcharges can be included into the price, and will be verified with nodes Supplements/Surcharges.
type Price implements Priceable {
  # Currency code indicating which currency should be paid.
  # This information is mandatory.
  currency: Currency!
  
  # It indicates if the price indicated in the gross must be respected.
  # That is, the customer can not sell the room / option at a price lower than that established by the supplier.
  # This information is mandatory.
  binding: Boolean!
  
  # Indicates the net price that the customer must pay to the supplier.
  # This information is mandatory.
  net: Float!
  
  # Indicates the retail price that the supplier sells to the customer.
  gross: Float
  
  # Provides information about the currency of original, and its rate applied over the results returned by the Supplier.
  # This information is mandatory.
  exchange: Exchange!
  
  # Informs markup applied over supplier price.
  markups: [Markup!]
}

# Information about daily price.
type PriceBreakdown {
  # Start date in which the price becomes effective.
  effectiveDate: Date!
  
  # Expire date of price.
  expireDate: Date!
  
  # Specifies the daily price.
  price: Price!
}

# Information about room promotions(offers).
type Promotion {
  # Specifies the promotion code.
  code: String!
  
  # Specifies the promotion name.
  name: String
  
  # Promotion effective date.
  effectiveDate: Date
  
  # Promotion expire date.
  expireDate: Date
}

# Returns the total price and cancellation policies of the Option selected in the previous step (Search).
type Quote {
  # Returns the total price and cancellation policies of the Option selected in the previous step (Search).
  hotel(criteria: HotelCriteriaQuoteInput!, settings: HotelSettingsInput): HotelQuote @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
}

# Information about the rate of the option returned.
type RatePlan {
  # Specifies the rate code.
  code: String!
  
  # Specifies the rate name.
  name: String
  
  # Start date in which the rate becomes effective.
  effectiveDate: Date
  
  # Expire date of the rate.
  expireDate: Date
}

# Contains reference codes.
type Reference {
  # Client reference booking
  client: String
  
  # Supplier reference booking
  supplier: String
}

# Contains information about the Resort.
type Resort {
  # Specifies the resort code.
  code: String!
  
  # Specifies the resort name.
  name: String
  
  # Specifies the resort description.
  description: String
}

# Contains the room information of the option returned.
type Room {
  # ID reference to the occupancy
  occupancyRefId: Int!
  
  # Indicates the room code
  code: String!
  
  # Description about the room
  description: String
  
  # Identifies if the room is refundable or not.
  refundable: Boolean
  
  # Number of rooms available with the same type.
  units: Int
  
  # Specifies the room price.
  roomPrice: RoomPrice!
  
  # List of beds.
  beds: [Bed!]
  
  # Daily break downs rate plan.
  ratePlans: [RatePlan!]
  
  # Daily break downs promotions.
  promotions: [Promotion!]
}

# Occupancy for a room. It contains a list of pax ages.
type RoomCriteria {
  # Array of pax ages. The number of items in the array will indicate the pax occupancy.
  paxes: [Pax!]!
}

# Specifies the room price.
type RoomPrice {
  # Total price for all days.
  price: Price!
  
  # Daily break downs price.
  breakdown: [PriceBreakdown!]
}

type Rule {
  # rule identifier
  id: String!
  
  # rule name
  name: String
  
  # type of the value
  type: MarkupRuleType!
  
  # value applied by this rule
  value: Float!
}

# Available options for a given date and itinerary. It does not filter different classes, times or
# fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
# forward.
type Search {
  # Available options of an hotel for a given date and itinerary. It does not filter different classes, times or
  # fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
  # forward. It only requires the criteria of search (destination, travel dates and the number of pax in each room).
  # But you must preload the other fields in our system by complete the fields absents.
  hotel(token: String, criteria: HotelCriteriaSearchInput, settings: HotelSettingsInput, filter: FilterInput): HotelSearch @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
}

# Indicates the status of the service
type ServiceStatus{
  # Status code
  code: String
  
  # Status type
  type: String
  
  # Status description
  description : String
}

type Stat {
  # Start UTC
  start:      DateTime!
  
  # End UTC
  end:        DateTime!
  
  # Difference between start and end in miliseconds
  duration:   Float
}

type StatAccess {
  # Access name
  name:                   String!
  
  # Total access time
  total:                  Stat!
  
  # Static configuration time
  staticConfiguration:    Stat
  
  # Number of hotels
  hotels:                 Int!
  
  # Number of zones
  zones:                  Int!
  
  # Number of cities
  cities:                 Int!
  
  # Access request time
  requestAccess:          StatPlugin
  
  # Access response time
  responseAccess:         StatPlugin
  
  # Detail transaction time
  transactions:           [StatTransaction!]!
  
  # Plugin execution time
  plugins:                [StatPlugin!]
}

type StatPlugin{
  # Plugin name
  name:     String!
  
  # total plugin time
  total:    Stat!
}

# Contains internal information.
type StatsRequest {
  # Total transaction time
  total:          Stat!
  
  # Request validation time
  validation:     Stat!
  
  # Process time. Contains communication time, parse time and plugin time.
  process:        Stat!
  
  # Build access time
  configuration:	Stat!
  
  # Request time
  request:				Stat!
  
  # Response time
  response:       Stat!
  
  # Plugin execution time
  requestPlugin:  StatPlugin
  
  # Plugin execution time
  responsePlugin: StatPlugin
  
  # Number of hotels
  hotels:         Int!
  
  # Number of zones
  zones:          Int!
  
  # Number of cities
  cities:         Int!
  
  # Docker Id
  dockerID:       String!
  
  # Detail access time
  Accesses:       [StatAccess!]!
}

type StatTransaction {
  # Extra information about transaction.
  reference:              String!
  
  # Total transaction time
  total:                  Stat!
  
  # Build request time
  buildRequest:           Stat!
  
  # Worker connection time
  workerCommunication:    Stat!
  
  # Parse response time
  parseResponse:          Stat!
}

# Supplement that it can be or its already added to the option returned. Contains all the information about the supplement.
type Supplement {
  # Specifies the supplement code.
  code: String!
  
  # Specifies the supplement name.
  name: String
  
  # Specifies the supplement description.
  description: String
  
  # Indicates the supplement type. Possible types: Fee, Ski_pass, Lessons, Meals, Equipment, Ticket, Transfers, Gla, Activity or Null.
  supplementType: SupplementType!
  
  # Indicates the charge types. We need to know whether the supplements have to be paid when the consumer gets to the hotel or beforehand.
  # Possible charge types: Include or Exclude.
  # when include: this supplement is mandatory and included in the option's price
  # when exclude: this supplement is not included in the option's price
  chargeType: ChargeType!
  
  # Indicates if the supplement is mandatory or not. If mandatory, this supplement will be applied to this option
  # if the chargeType is excluded the customer will have to pay it directly at the hotel
  mandatory: Boolean!
  
  # Specifies the duration type. Possible duration types: Range (specified dates) or Open. This field is mandatory for PDI.
  durationType: DurationType
  
  # Indicates the quantity of field in the element "unit".
  quantity: Int
  
  # Indicates the unit type. Possible unit types: Day or Hour.
  unit: UnitTimeType
  
  # Indicates the effective date of the supplement.
  effectiveDate: Date
  
  # Indicates the expire date of the supplement.
  expireDate: Date
  
  # Contains information about the resort
  resort: Resort
  
  # Indicates the supplement price.
  price: Price
}

# Surcharge that it can be or it is already added to the option returned. Contains all the information about the surcharge.
type Surcharge {
  # Indicates the charge types. We need to know whether the supplements have to be paid when the consumer gets to the hotel or beforehand.
  # Possible charge types: Include or Exclude.
  # when include: this surcharge is mandatory and included in the option's price
  # when exclude: this surcharge is not included in the option's price
  chargeType: ChargeType!
  
  # Indicates if the surcharge is mandatory or not. If mandatory, this surcharge will be applied to this option
  # if the chargeType is excluded the customer will have to pay it directly at the hotel
  mandatory: Boolean!
  
  # Indicates the surcharge price.
  price: Price!
  
  # Specifies the surcharge description.
  description: String
}

type Timeout {
  # Milliseconds before the search connection is closed.
  search: Int!
  
  # Milliseconds before the quote connection is closed.
  quote: Int!
  
  # Milliseconds before the book connection is closed.
  book: Int!
}

# Supplier transaction
type Transactions {
  # Transaction Request.
  request:        String!
  
  # Transaction Response.
  response:       String!
  
  # Time when the request has been processed.
  timeStamp:      DateTime!
}

## AddOrganization
input MappeaAddOrganizationInput {
  name: String!
  isActive : Boolean!
  isTest: Boolean!
}

### ConfirmUpload
input MappeaConfirmUploadInput {
  fileId: Int!
  suppliers: [MappeaSupplierConfirmedInput!]!
}

## EditOrganization
input MappeaEditOrganizationInput {
  name: String!
  isActive : Boolean
  isTest: Boolean
}

## GetMappeaStats
input MappeaGetMappeaStatsInput {
  organizationName: String!
  supplierMapped: String
}

## MapSupplier
input MappeaMapSupplierInput {
  requestId: ID!
  access: ID!
  fileId: Int!
}

input MappeaSupplierConfirmedInput {
  code: ID!
  supplier: ID!
}

### UploadFile
input MappeaUploadFileInput {
  requestId: String!
  fileName: String
  delimiter: String!
  fileContent: String!
}

type File {
  fileName: String!
  fileId: Int!
  uploadTime: String!
}

type GetMappeaStatsData {
  supplierMapped: String
  startTime: String
  endTime: String
  organizationHotels: Int
  contextHotels: Int
  suggestedHotels: Int
}

type GetMappeaStatsResponse {
  data: [GetMappeaStatsData]
  error: Error
  warnings: [Warning]
}

type GetUploadedFilesData {
  files: [File]
}

### GetUploadedFiles
type GetUploadedFilesResponse {
  data: GetUploadedFilesData
  error: Error
  warnings: [Warning]
}

### Common Items
type OnlyStatusResponse {
  error: Error
  warnings: [Warning]
}

type SupplierDetected {
  code: ID!
  supplier: Supplier
  numberOfHotels: Int!
}

type UploadFileData {
  fileId: String!
  suppliers: [SupplierDetected!]
  numberOfLines: Int
  numberOfHotels: Int
}

type UploadFileResponse {
  data: UploadFileData
  error: Error
  warnings: [Warning]
}

input PaymentXBookingInfoDeleteInput {
  
  # Responsible organization of the booked property.
  organization : String!
  
  # Indicates the code of the booked property
  pointOfSaleCode: ID!
  
  # Indicates the referece of the booking
  bookingReference: String!
  
}

input PaymentXBookingInfoFilterInput {
  
  # Responsible organization of the booked property.
  organization : String!
  
  # Indicates the code of the booked property
  pointOfSaleCode: ID!
  
  # Indicates the referece of the booking
  bookingReference: String!
  
}

input PaymentXBookingInfoInput {
  
  # Responsible organization of the booked property.
  organization : String!
  
  # Indicates the code of the booked property
  pointOfSale: PointOfSaleInput!
  
  # Indicates the referece of the booking
  bookingReference: String!
  
  # Check-out, booking date Format: YYYY-MM-DD
  checkOut : Date!
  
  # Check-in, booking date Format: YYYY-MM-DD
  checkIn : Date!
}

input PaymentXStoreCardInput {
  bookingInfo: PaymentXBookingInfoInput!
  card: PaymentCardInput!
}

input PointOfSaleInput {
  # POS Identifier
  code: ID!
  # POS Name
  name: String!
}

# The card expiration date
type ExpireDate{
  # Month MM
  month: Int!
  
  # Year yy
  year: Int!
}

# Input PaymentCard, if the payment is done by credit card, is it mandatory to specify the payment type and the credit card information
type PaymentCard {
  # Indicates the card type.
  cardType: String!
  
  # Contains owner's name
  holder: Holder!
  
  # Card Number (16 digits typically)
  number: CardNumber!
  
  # Contains credit card CVC
  CVC: CVC!
  
  # Contains credit card expiration date
  expire: ExpireDate!
}

type PaymentXBookingInfo{ 
  
  # Responsible organization of the booked property.
  organization : String!
  
  pointOfSale : PointOfSale!
  
  # Indicates the referece of the booking
  bookingReference: String!
  
  # Check-out, booking date Format: YYYY-MM-DD
  checkOut : Date!
  
  # Check-in, booking date Format: YYYY-MM-DD
  checkIn : Date!
  
}

type StoredCard implements Node{
  code: ID!
  
  storedCardData: StoredCardData
  
  # Create date
  createdAt: DateTime!
  
  # Update date
  updatedAt: DateTime!
  
  # List of messages
  adviseMessage(level: [AdviseMessageLevel]): [AdviseMessage!]
}

type StoredCardConnection{
  edges: [StoredCardEdge]
  pageInfo: PageInfo!
}

type StoredCardData { 
  bookingInfo: PaymentXBookingInfo!
  card: PaymentCard!
}

type StoredCardEdge{
  cursor: String!
  node: StoredCard
}

scalar CardNumber

scalar CVC

# Services Api available.
enum ServiceApiType {
  # When the request has been done against the Hotel API
  HOTEL
  # When the request has been done against the Transportation API
  TRANSPORTATION
  # When the request has been done against the Car API
  CAR
  # When the request has been done against the Transfers API
  TRANSFERS
  # When the request has been done against the Activities API
  ACTIVITIES
  # When the request has been done against the Virtual Account API
  VIRTUALACCOUNT
  # When the request has been done against the Payment API
  PAYMENT
  # When the request has been done against the Package API
  PACKAGE
}

enum ServiceOperationType {
  ALL
  # When the type of the request is Search
  SEARCH
  # When the type of the request is Quote
  QUOTE
  # When the type of the request is Booking
  BOOKING
  # When the type of the request is Other
  OTHER
}

enum StatsInfoTypes{
  ALL
  # Stats in OK state
  OK
  # Stats in NOK state caused by integration issues
  INTEGRATION
  # Stats in NOK state caused by supplier issues
  PROVIDER
  # Stats in NOK state caused by Timeout
  COMMUNICATION
  # Stats in NOK state caused by HUB issues
  HUB
  # Stats in NOK state caused by other causes
  OTHER
}

# Filters needed to do a search.
# Users (List of users), Suppliers (List of suppliers), ServiceApis (List of service apis), From (Start date of search - YYYY-MM-DD HH:mm:ss), To (End date of search - YYYY-MM-DD HH:mm:ss)
input StatsFilterInput {
  # List of organizations
  organizations: [ID!]

  # List of accesses
  accesses: [ID!]

  # List of suppliers
  suppliers: [ID!]
  
  # List of services apis
  serviceApis: [ServiceApiType!]
  
  # List of services operations
  operation: [ServiceOperationType!]
  serviceOperations: [ID!]
  
  # From date of search
  from: DateTime!
  
  # To date of search
  to: DateTime!
}

# Stats information per operation
type OperationDetailed {
  # Operation information
  operation: Operation!
  # Total hits.
  totalHits: Int!
  # Hits grouped depending on their status
  detailedHits(type: [StatsInfoTypes!], code:[Int!]): [StatsInfo!]
  # Responsible for the execution of the this stats. If TRUE then cache, else client
  cache: Boolean!
}

# Ratios details
type Ratios {
  # Searches needed to do a quote
  lookToQuote: Int!
  # Searches needed to do a booking
  lookToBook: Int!
  # Quotes needed to do a booking
  quoteToBook: Int!
}

# The service used to access the stats of every connection that uses the HUB
type Stats implements Node {
  code: ID! #GUID
  # The data returned by a `Stats` query.
  statsData: StatsData
  # Errors that will lead the service to abort
  error: [Error!]
  # Create date
  createdAt: DateTime!
  # Update date
  updatedAt: DateTime!
}

# Assert of an specific error
type StatsAssert {
  # Start time of the request
  startTime: DateTime!
  # Execution time of the request
  execTime: Int!
  # Endpoint to download the full XML of the request with its response
  url: URI!
}

type StatsConnection {
  edges: [StatsEdge]
  pageInfo: PageInfo!
}

type StatsData{
  # Owner access
  access: Access!
  # Owner client
  client: Client!
  # From date of search
  from: DateTime!
  # To date of search
  to: DateTime!
  # Ratios details
  ratios: Ratios!
  # Stats information per operation
  operations(type:[ServiceOperationType!]):[OperationDetailed!]
}

type StatsEdge{
  cursor: String!
  node: Stats
}

# Details of an specific error
type StatsInfo {
  code: ID!
  # Stats type
  type: StatsInfoTypes!
  # Total hits
  hits: Int!
  # Average time (ms)
  time: Int!
  # Details about errors.
  asserts:[StatsAssert!]
}
